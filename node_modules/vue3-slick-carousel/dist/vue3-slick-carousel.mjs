import { createVNode as S, createTextVNode as ie, mergeProps as x, isVNode as xe } from "vue";
import { pick as $e, assign as Ce, get as Le, debounce as Ee } from "lodash";
var ze = function(e) {
  return e.replace(/[A-Z]/g, function(t) {
    return "-" + t.toLowerCase();
  }).toLowerCase();
}, Re = ze, Me = Re, We = function(e) {
  var t = /[height|width]$/;
  return t.test(e);
}, se = function(e) {
  var t = "", i = Object.keys(e);
  return i.forEach(function(s, r) {
    var l = e[s];
    s = Me(s), We(s) && typeof l == "number" && (l = l + "px"), l === !0 ? t += s : l === !1 ? t += "not " + s : t += "(" + s + ": " + l + ")", r < i.length - 1 && (t += " and ");
  }), t;
}, Pe = function(e) {
  var t = "";
  return typeof e == "string" ? e : e instanceof Array ? (e.forEach(function(i, s) {
    t += se(i), s < e.length - 1 && (t += ", ");
  }), t) : se(e);
}, re = Pe;
const fe = {
  computed: {
    isPropsUpdated() {
      return Object.keys(this.$props).forEach((e) => this[e]), this.updateSwitch = !this.updateSwitch;
    }
  },
  watch: {
    isPropsUpdated() {
      typeof this.onPropsUpdated == "function" && this.onPropsUpdated();
    }
  }
}, T = (e, t, i) => {
  !e || (e.data = e.data || {}, e.data[t] = {
    ...e.data[t],
    ...i
  });
}, pe = (e, t, i) => {
  !e || (e.data = e.data || {}, e.data[t] = i);
}, Ae = [
  "class",
  "staticClass",
  "style",
  "attrs",
  "props",
  "domProps",
  "on",
  "nativeOn",
  "directives",
  "scopesSlots",
  "slot",
  "ref",
  "key"
];
function De(e) {
  return "" + e + "-cloned-cid";
}
function He(e, t) {
  const i = $e(e.data, Ae);
  if (t) {
    const s = e.componentOptions;
    Ce(i, {
      props: s.propsData,
      on: s.listeners
    });
  }
  return i.key && (i.key = De(i.key)), i;
}
const Q = (e) => {
  const t = e.context && e.context.$createElement, i = !!e.componentOptions, s = !e.tag, r = i ? e.componentOptions.children : e.children;
  if (s)
    return e.text;
  const l = He(e, i), n = i ? e.componentOptions.Ctor : e.tag, o = r ? r.map((a) => Q(a)) : void 0;
  return t(n, l, o);
}, q = (e, t, i) => {
  if (!e)
    return;
  const s = e.data || {};
  return typeof t > "u" ? s : Le(s, t, i);
}, V = (e) => ({
  ...q(e, "staticStyle", {}),
  ...q(e, "style", {})
}), ve = () => !!(typeof window < "u" && window.document && window.document.createElement), O = (e) => e.unslick || !e.infinite ? 0 : e.variableWidth ? e.slideCount : e.slidesToShow + (e.centerMode ? 1 : 0), G = (e) => e.unslick || !e.infinite ? 0 : e.slideCount, Ie = (e, t, i) => e.target.tagName.match("TEXTAREA|INPUT|SELECT") || !t ? "" : e.keyCode === 37 ? i ? "next" : "previous" : e.keyCode === 39 ? i ? "previous" : "next" : "", Ne = (e) => e.targetSlide > e.currentSlide ? e.targetSlide > e.currentSlide + Be(e) ? "left" : "right" : e.targetSlide < e.currentSlide - je(e) ? "right" : "left", Be = ({
  slidesToShow: e,
  centerMode: t,
  rtl: i,
  centerPadding: s
}) => {
  if (t) {
    let r = (e - 1) / 2 + 1;
    return parseInt(s) > 0 && (r += 1), i && e % 2 === 0 && (r += 1), r;
  }
  return i ? 0 : e - 1;
}, je = ({
  slidesToShow: e,
  centerMode: t,
  rtl: i,
  centerPadding: s
}) => {
  if (t) {
    let r = (e - 1) / 2 + 1;
    return parseInt(s) > 0 && (r += 1), !i && e % 2 === 0 && (r += 1), r;
  }
  return i ? e - 1 : 0;
}, ge = (e) => e.currentSlide - Ye(e), ye = (e) => e.currentSlide + Fe(e), Ye = (e) => e.centerMode ? Math.floor(e.slidesToShow / 2) + (parseInt(e.centerPadding) > 0 ? 1 : 0) : 0, Fe = (e) => e.centerMode ? Math.floor((e.slidesToShow - 1) / 2) + 1 + (parseInt(e.centerPadding) > 0 ? 1 : 0) : e.slidesToShow, D = (e) => {
  let t = [], i = ge(e), s = ye(e);
  for (let r = i; r < s; r++)
    e.lazyLoadedList.indexOf(r) < 0 && t.push(r);
  return t;
}, Xe = (e, t) => {
  var i, s, r, l, n;
  const {
    slidesToScroll: o,
    slidesToShow: a,
    slideCount: d,
    currentSlide: f,
    lazyLoad: p,
    infinite: y
  } = e;
  if (l = d % o !== 0, i = l ? 0 : (d - f) % o, t.message === "previous")
    r = i === 0 ? o : a - i, n = f - r, p && !y && (s = f - r, n = s === -1 ? d - 1 : s);
  else if (t.message === "next")
    r = i === 0 ? o : i, n = f + r, p && !y && (n = (f + o) % d + i);
  else if (t.message === "dots") {
    if (n = t.index * t.slidesToScroll, n === t.currentSlide)
      return null;
  } else if (t.message === "children") {
    if (n = t.index, n === t.currentSlide)
      return null;
    if (y) {
      let g = Ne({ ...e, targetSlide: n });
      n > t.currentSlide && g === "left" ? n = n - d : n < t.currentSlide && g === "right" && (n = n + d);
    }
  } else if (t.message === "index" && (n = Number(t.index), n === t.currentSlide))
    return null;
  return n;
}, M = (e) => Object.keys(e).filter((t) => e[t] !== void 0).reduce((t, i) => (t[i] = e[i], t), {}), qe = (e) => Object.keys(e).filter((t) => e[t] !== void 0 && e[t] !== null).reduce((t, i) => (t[i] = e[i], t), {}), Ve = (e, t, i) => !t || !i && e.type.indexOf("mouse") !== -1 ? "" : {
  dragging: !0,
  touchObject: {
    startX: e.touches ? e.touches[0].pageX : e.clientX,
    startY: e.touches ? e.touches[0].pageY : e.clientY,
    curX: e.touches ? e.touches[0].pageX : e.clientX,
    curY: e.touches ? e.touches[0].pageY : e.clientY
  }
}, Ge = (e, t) => {
  const {
    scrolling: i,
    animating: s,
    vertical: r,
    swipeToSlide: l,
    verticalSwiping: n,
    rtl: o,
    currentSlide: a,
    edgeFriction: d,
    edgeDragged: f,
    onEdge: p,
    swiped: y,
    swiping: g,
    slideCount: c,
    slidesToScroll: u,
    infinite: v,
    touchObject: h,
    swipeEvent: m,
    listHeight: w,
    listWidth: k
  } = t;
  if (i)
    return;
  if (s)
    return e.preventDefault();
  r && l && n && e.preventDefault();
  let b, _ = {}, A = W(t);
  h.curX = e.touches ? e.touches[0].pageX : e.clientX, h.curY = e.touches ? e.touches[0].pageY : e.clientY, h.swipeLength = Math.round(
    Math.sqrt(Math.pow(h.curX - h.startX, 2))
  );
  let te = Math.round(
    Math.sqrt(Math.pow(h.curY - h.startY, 2))
  );
  if (!n && !g && te > 10)
    return { scrolling: !0 };
  n && (h.swipeLength = te);
  let E = (o ? -1 : 1) * (h.curX > h.startX ? 1 : -1);
  n && (E = h.curY > h.startY ? 1 : -1);
  let Oe = Math.ceil(c / u), z = Se(t.touchObject, n), R = h.swipeLength;
  return v || (a === 0 && z === "right" || a + 1 >= Oe && z === "left" || !N(t) && z === "left") && (R = h.swipeLength * d, f === !1 && p && (p(z), _.edgeDragged = !0)), !y && m && (m(z), _.swiped = !0), r ? b = A + R * (w / k) * E : o ? b = A - R * E : b = A + R * E, n && (b = A + R * E), _ = {
    ..._,
    touchObject: h,
    swipeLeft: b,
    trackStyle: P({ ...t, left: b })
  }, Math.abs(h.curX - h.startX) < Math.abs(h.curY - h.startY) * 0.8 || h.swipeLength > 10 && (_.swiping = !0, e.preventDefault()), _;
}, Ke = (e, t) => {
  const {
    dragging: i,
    swipe: s,
    touchObject: r,
    listWidth: l,
    touchThreshold: n,
    verticalSwiping: o,
    listHeight: a,
    currentSlide: d,
    swipeToSlide: f,
    scrolling: p,
    onSwipe: y
  } = t;
  if (!i)
    return s && e.preventDefault(), {};
  let g = o ? a / n : l / n, c = Se(r, o), u = {
    dragging: !1,
    edgeDragged: !1,
    scrolling: !1,
    swiping: !1,
    swiped: !1,
    swipeLeft: null,
    touchObject: {}
  };
  if (p || !r.swipeLength)
    return u;
  if (r.swipeLength > g) {
    e.preventDefault(), y && y(c);
    let v, h;
    switch (c) {
      case "left":
      case "up":
        h = d + le(t), v = f ? ne(t, h) : h, u.currentDirection = 0;
        break;
      case "right":
      case "down":
        h = d - le(t), v = f ? ne(t, h) : h, u.currentDirection = 1;
        break;
      default:
        v = d;
    }
    u.triggerSlideHandler = v;
  } else {
    let v = W(t);
    u.trackStyle = me({ ...t, left: v });
  }
  return u;
}, Ue = (e) => {
  let t = e.infinite ? e.slideCount * 2 : e.slideCount, i = e.infinite ? e.slidesToShow * -1 : 0, s = e.infinite ? e.slidesToShow * -1 : 0, r = [];
  for (; i < t; )
    r.push(i), i = s + e.slidesToScroll, s += Math.min(e.slidesToScroll, e.slidesToShow);
  return r;
}, ne = (e, t) => {
  const i = Ue(e);
  let s = 0;
  if (t > i[i.length - 1])
    t = i[i.length - 1];
  else
    for (let r in i) {
      if (t < i[r]) {
        t = s;
        break;
      }
      s = i[r];
    }
  return t;
}, le = (e) => {
  const t = e.centerMode ? e.slideWidth * Math.floor(e.slidesToShow / 2) : 0;
  if (e.swipeToSlide) {
    let i;
    const r = e.listRef.querySelectorAll(".slick-slide");
    if (Array.from(r).every((o) => {
      if (e.vertical) {
        if (o.offsetTop + Z(o) / 2 > e.swipeLeft * -1)
          return i = o, !1;
      } else if (o.offsetLeft - t + K(o) / 2 > e.swipeLeft * -1)
        return i = o, !1;
      return !0;
    }), !i)
      return 0;
    const l = e.rtl === !0 ? e.slideCount - e.currentSlide : e.currentSlide;
    return Math.abs(i.dataset.index - l) || 1;
  } else
    return e.slidesToScroll;
}, j = (e, t) => {
  let i = {};
  return t.forEach((s) => i[s] = e[s]), i;
}, $ = {
  TRACK: [
    "fade",
    "cssEase",
    "speed",
    "infinite",
    "centerMode",
    "currentSlide",
    "lazyLoad",
    "lazyLoadedList",
    "rtl",
    "slideWidth",
    "slideHeight",
    "listHeight",
    "vertical",
    "slidesToShow",
    "slidesToScroll",
    "slideCount",
    "trackStyle",
    "variableWidth",
    "unslick",
    "centerPadding"
  ],
  DOT: [
    "dotsClass",
    "slideCount",
    "slidesToShow",
    "currentSlide",
    "slidesToScroll",
    "children",
    "customPaging",
    "infinite"
  ],
  ARROW: [
    "infinite",
    "centerMode",
    "currentSlide",
    "slideCount",
    "slidesToShow",
    "prevArrow",
    "nextArrow"
  ]
}, N = (e) => {
  let t = !0;
  return e.infinite || (e.centerMode && e.currentSlide >= e.slideCount - 1 || e.slideCount <= e.slidesToShow || e.currentSlide >= e.slideCount - e.slidesToShow) && (t = !1), t;
}, Qe = (e) => {
  const {
    waitForAnimate: t,
    animating: i,
    fade: s,
    infinite: r,
    index: l,
    slideCount: n,
    lazyLoadedList: o,
    lazyLoad: a,
    currentSlide: d,
    centerMode: f,
    slidesToScroll: p,
    slidesToShow: y,
    useCSS: g
  } = e;
  if (t && i)
    return {};
  let c = l, u, v, h, m = {}, w = {};
  if (s) {
    if (!r && (l < 0 || l >= n))
      return {};
    l < 0 ? c = l + n : l >= n && (c = l - n), a && o.indexOf(c) < 0 && o.push(c), m = {
      animating: !0,
      currentSlide: c,
      lazyLoadedList: o
    }, w = { animating: !1 };
  } else
    u = c, c < 0 ? (u = c + n, r ? n % p !== 0 && (u = n - n % p) : u = 0) : !N(e) && c > d ? c = u = d : f && c >= n ? (c = r ? n : n - 1, u = r ? 0 : n - 1) : c >= n && (u = c - n, r ? n % p !== 0 && (u = 0) : u = n - y), v = W({ ...e, slideIndex: c }), h = W({ ...e, slideIndex: u }), r || (v === h && (c = u), v = h), a && o.concat(
      D({ ...e, currentSlide: c })
    ), g ? (m = {
      animating: !0,
      currentSlide: u,
      trackStyle: me({ ...e, left: v }),
      lazyLoadedList: o
    }, w = {
      animating: !1,
      currentSlide: u,
      trackStyle: P({ ...e, left: h }),
      swipeLeft: null
    }) : m = {
      currentSlide: u,
      trackStyle: P({ ...e, left: h }),
      lazyLoadedList: o
    };
  return { state: m, nextState: w };
}, K = (e) => e && e.offsetWidth || 0, Z = (e) => e && e.offsetHeight || 0, Se = (e, t = !1) => {
  var i, s, r, l;
  return i = e.startX - e.curX, s = e.startY - e.curY, r = Math.atan2(s, i), l = Math.round(r * 180 / Math.PI), l < 0 && (l = 360 - Math.abs(l)), l <= 45 && l >= 0 || l <= 360 && l >= 315 ? "left" : l >= 135 && l <= 225 ? "right" : t === !0 ? l >= 35 && l <= 135 ? "up" : "down" : "vertical";
}, Ze = (e) => {
  let t = e.children.length, i = Math.ceil(K(e.listRef)), s = Math.ceil(K(e.trackRef)), r;
  if (e.vertical)
    r = i;
  else {
    let p = e.centerMode && parseInt(e.centerPadding) * 2;
    typeof e.centerPadding == "string" && e.centerPadding.slice(-1) === "%" && (p *= i / 100), r = Math.ceil((i - p) / e.slidesToShow);
  }
  let l = e.listRef && Z(e.listRef.querySelector('[data-index="0"]')), n = l * e.slidesToShow, o = e.currentSlide === void 0 ? e.initialSlide : e.currentSlide;
  e.rtl && e.currentSlide === void 0 && (o = t - 1 - e.initialSlide);
  let a = e.lazyLoadedList || [], d = D(
    { currentSlide: o, lazyLoadedList: a }
  );
  a.concat(d);
  let f = {
    slideCount: t,
    slideWidth: r,
    listWidth: i,
    trackWidth: s,
    currentSlide: o,
    slideHeight: l,
    listHeight: n,
    lazyLoadedList: a
  };
  return e.autoplaying === null && e.autoplay && (f.autoplaying = "playing"), f;
}, W = (e) => {
  if (e.unslick)
    return 0;
  J(e, [
    "slideIndex",
    "trackRef",
    "infinite",
    "centerMode",
    "slideCount",
    "slidesToShow",
    "slidesToScroll",
    "slideWidth",
    "listWidth",
    "variableWidth",
    "slideHeight"
  ]);
  const {
    slideIndex: t,
    trackRef: i,
    infinite: s,
    centerMode: r,
    slideCount: l,
    slidesToShow: n,
    slidesToScroll: o,
    slideWidth: a,
    listWidth: d,
    variableWidth: f,
    slideHeight: p,
    fade: y,
    vertical: g
  } = e;
  var c = 0, u, v, h = 0;
  if (y || e.slideCount === 1)
    return 0;
  let m = 0;
  if (s ? (m = -O(e), l % o !== 0 && t + o > l && (m = -(t > l ? n - (t - l) : l % o)), r && (m += parseInt(n / 2))) : (l % o !== 0 && t + o > l && (m = n - l % o), r && (m = parseInt(n / 2))), c = m * a, h = m * p, g ? u = t * p * -1 + h : u = t * a * -1 + c, f === !0) {
    var w;
    let k = i.$el;
    if (w = t + O(e), v = k && k.childNodes[w], u = v ? v.offsetLeft * -1 : 0, r === !0) {
      w = s ? t + O(e) : t, v = k && k.children[w], u = 0;
      for (let b = 0; b < w; b++)
        u -= k && k.children[b] && k.children[b].offsetWidth;
      u -= parseInt(e.centerPadding), u += v && (d - v.offsetWidth) / 2;
    }
  }
  return u;
}, Je = (e) => e.slideCount === 1 ? 1 : O(e) + e.slideCount + G(e), J = (e, t) => t.reduce((i, s) => i && e.hasOwnProperty(s), !0) ? null : console.error("Keys Missing:", e), P = (e) => {
  J(e, [
    "left",
    "variableWidth",
    "slideCount",
    "slidesToShow",
    "slideWidth"
  ]);
  let t, i;
  const s = e.slideCount + 2 * e.slidesToShow;
  e.vertical ? i = s * e.slideHeight : t = Je(e) * e.slideWidth;
  let r = {
    opacity: 1,
    transition: "",
    WebkitTransition: ""
  };
  if (e.useTransform) {
    let l = e.vertical ? "translate3d(0px, " + e.left + "px, 0px)" : "translate3d(" + e.left + "px, 0px, 0px)", n = e.vertical ? "translate3d(0px, " + e.left + "px, 0px)" : "translate3d(" + e.left + "px, 0px, 0px)", o = e.vertical ? "translateY(" + e.left + "px)" : "translateX(" + e.left + "px)";
    r = {
      ...r,
      WebkitTransform: l,
      transform: n,
      msTransform: o
    };
  } else
    e.vertical ? r.top = e.left : r.left = e.left;
  return e.fade && (r = { opacity: 1 }), t && (r.width = t + "px"), i && (r.height = i + "px"), window && !window.addEventListener && window.attachEvent && (e.vertical ? r.marginTop = e.left + "px" : r.marginLeft = e.left + "px"), r;
}, me = (e) => {
  J(e, [
    "left",
    "variableWidth",
    "slideCount",
    "slidesToShow",
    "slideWidth",
    "speed",
    "cssEase"
  ]);
  let t = P(e);
  return e.useTransform ? (t.WebkitTransition = "-webkit-transform " + e.speed + "ms " + e.cssEase, t.transition = "transform " + e.speed + "ms " + e.cssEase) : e.vertical ? t.transition = "top " + e.speed + "ms " + e.cssEase : t.transition = "left " + e.speed + "ms " + e.cssEase, t;
}, C = {
  accessibility: { type: Boolean, default: !0 },
  adaptiveHeight: { type: Boolean, default: !1 },
  arrows: { type: Boolean, default: !0 },
  asNavFor: { type: Object, default: null },
  autoplay: { type: Boolean, default: !1 },
  autoplaySpeed: { type: Number, default: 3e3 },
  centerMode: { type: Boolean, default: !1 },
  centerPadding: { type: String, default: "50px" },
  cssEase: { type: String, default: "ease" },
  dots: { type: Boolean, default: !1 },
  dotsClass: { type: String, default: "slick-dots" },
  draggable: { type: Boolean, default: !0 },
  edgeFriction: { type: Number, default: 0.35 },
  fade: { type: Boolean, default: !1 },
  focusOnSelect: { type: Boolean, default: !1 },
  infinite: { type: Boolean, default: !0 },
  initialSlide: { type: Number, default: 0 },
  lazyLoad: { type: String, default: null },
  pauseOnDotsHover: { type: Boolean, default: !1 },
  pauseOnFocus: { type: Boolean, default: !1 },
  pauseOnHover: { type: Boolean, default: !0 },
  responsive: { type: Array, default: null },
  rows: { type: Number, default: 1 },
  rtl: { type: Boolean, default: !1 },
  slidesPerRow: { type: Number, default: 1 },
  slidesToScroll: { type: Number, default: 1 },
  slidesToShow: { type: Number, default: 1 },
  speed: { type: Number, default: 500 },
  swipe: { type: Boolean, default: !0 },
  swipeToSlide: { type: Boolean, default: !1 },
  touchMove: { type: Boolean, default: !0 },
  touchThreshold: { type: Number, default: 5 },
  useCSS: { type: Boolean, default: !0 },
  useTransform: { type: Boolean, default: !0 },
  variableWidth: { type: Boolean, default: !1 },
  vertical: { type: Boolean, default: !1 },
  waitForAnimate: { type: Boolean, default: !0 }
}, oe = Object.keys(C).reduce((e, t) => (e[t] = C[t].default, e), {});
Object.keys(C).reduce((e, t) => (e[t] = C[t].type, e), {});
var we = function() {
  if (typeof Map < "u")
    return Map;
  function e(t, i) {
    var s = -1;
    return t.some(function(r, l) {
      return r[0] === i ? (s = l, !0) : !1;
    }), s;
  }
  return function() {
    function t() {
      this.__entries__ = [];
    }
    return Object.defineProperty(t.prototype, "size", {
      get: function() {
        return this.__entries__.length;
      },
      enumerable: !0,
      configurable: !0
    }), t.prototype.get = function(i) {
      var s = e(this.__entries__, i), r = this.__entries__[s];
      return r && r[1];
    }, t.prototype.set = function(i, s) {
      var r = e(this.__entries__, i);
      ~r ? this.__entries__[r][1] = s : this.__entries__.push([i, s]);
    }, t.prototype.delete = function(i) {
      var s = this.__entries__, r = e(s, i);
      ~r && s.splice(r, 1);
    }, t.prototype.has = function(i) {
      return !!~e(this.__entries__, i);
    }, t.prototype.clear = function() {
      this.__entries__.splice(0);
    }, t.prototype.forEach = function(i, s) {
      s === void 0 && (s = null);
      for (var r = 0, l = this.__entries__; r < l.length; r++) {
        var n = l[r];
        i.call(s, n[1], n[0]);
      }
    }, t;
  }();
}(), U = typeof window < "u" && typeof document < "u" && window.document === document, H = function() {
  return typeof global < "u" && global.Math === Math ? global : typeof self < "u" && self.Math === Math ? self : typeof window < "u" && window.Math === Math ? window : Function("return this")();
}(), et = function() {
  return typeof requestAnimationFrame == "function" ? requestAnimationFrame.bind(H) : function(e) {
    return setTimeout(function() {
      return e(Date.now());
    }, 1e3 / 60);
  };
}(), tt = 2;
function it(e, t) {
  var i = !1, s = !1, r = 0;
  function l() {
    i && (i = !1, e()), s && o();
  }
  function n() {
    et(l);
  }
  function o() {
    var a = Date.now();
    if (i) {
      if (a - r < tt)
        return;
      s = !0;
    } else
      i = !0, s = !1, setTimeout(n, t);
    r = a;
  }
  return o;
}
var st = 20, rt = ["top", "right", "bottom", "left", "width", "height", "size", "weight"], nt = typeof MutationObserver < "u", lt = function() {
  function e() {
    this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = it(this.refresh.bind(this), st);
  }
  return e.prototype.addObserver = function(t) {
    ~this.observers_.indexOf(t) || this.observers_.push(t), this.connected_ || this.connect_();
  }, e.prototype.removeObserver = function(t) {
    var i = this.observers_, s = i.indexOf(t);
    ~s && i.splice(s, 1), !i.length && this.connected_ && this.disconnect_();
  }, e.prototype.refresh = function() {
    var t = this.updateObservers_();
    t && this.refresh();
  }, e.prototype.updateObservers_ = function() {
    var t = this.observers_.filter(function(i) {
      return i.gatherActive(), i.hasActive();
    });
    return t.forEach(function(i) {
      return i.broadcastActive();
    }), t.length > 0;
  }, e.prototype.connect_ = function() {
    !U || this.connected_ || (document.addEventListener("transitionend", this.onTransitionEnd_), window.addEventListener("resize", this.refresh), nt ? (this.mutationsObserver_ = new MutationObserver(this.refresh), this.mutationsObserver_.observe(document, {
      attributes: !0,
      childList: !0,
      characterData: !0,
      subtree: !0
    })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = !0), this.connected_ = !0);
  }, e.prototype.disconnect_ = function() {
    !U || !this.connected_ || (document.removeEventListener("transitionend", this.onTransitionEnd_), window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = !1, this.connected_ = !1);
  }, e.prototype.onTransitionEnd_ = function(t) {
    var i = t.propertyName, s = i === void 0 ? "" : i, r = rt.some(function(l) {
      return !!~s.indexOf(l);
    });
    r && this.refresh();
  }, e.getInstance = function() {
    return this.instance_ || (this.instance_ = new e()), this.instance_;
  }, e.instance_ = null, e;
}(), be = function(e, t) {
  for (var i = 0, s = Object.keys(t); i < s.length; i++) {
    var r = s[i];
    Object.defineProperty(e, r, {
      value: t[r],
      enumerable: !1,
      writable: !1,
      configurable: !0
    });
  }
  return e;
}, L = function(e) {
  var t = e && e.ownerDocument && e.ownerDocument.defaultView;
  return t || H;
}, ke = B(0, 0, 0, 0);
function I(e) {
  return parseFloat(e) || 0;
}
function ae(e) {
  for (var t = [], i = 1; i < arguments.length; i++)
    t[i - 1] = arguments[i];
  return t.reduce(function(s, r) {
    var l = e["border-" + r + "-width"];
    return s + I(l);
  }, 0);
}
function ot(e) {
  for (var t = ["top", "right", "bottom", "left"], i = {}, s = 0, r = t; s < r.length; s++) {
    var l = r[s], n = e["padding-" + l];
    i[l] = I(n);
  }
  return i;
}
function at(e) {
  var t = e.getBBox();
  return B(0, 0, t.width, t.height);
}
function dt(e) {
  var t = e.clientWidth, i = e.clientHeight;
  if (!t && !i)
    return ke;
  var s = L(e).getComputedStyle(e), r = ot(s), l = r.left + r.right, n = r.top + r.bottom, o = I(s.width), a = I(s.height);
  if (s.boxSizing === "border-box" && (Math.round(o + l) !== t && (o -= ae(s, "left", "right") + l), Math.round(a + n) !== i && (a -= ae(s, "top", "bottom") + n)), !ht(e)) {
    var d = Math.round(o + l) - t, f = Math.round(a + n) - i;
    Math.abs(d) !== 1 && (o -= d), Math.abs(f) !== 1 && (a -= f);
  }
  return B(r.left, r.top, o, a);
}
var ut = function() {
  return typeof SVGGraphicsElement < "u" ? function(e) {
    return e instanceof L(e).SVGGraphicsElement;
  } : function(e) {
    return e instanceof L(e).SVGElement && typeof e.getBBox == "function";
  };
}();
function ht(e) {
  return e === L(e).document.documentElement;
}
function ct(e) {
  return U ? ut(e) ? at(e) : dt(e) : ke;
}
function ft(e) {
  var t = e.x, i = e.y, s = e.width, r = e.height, l = typeof DOMRectReadOnly < "u" ? DOMRectReadOnly : Object, n = Object.create(l.prototype);
  return be(n, {
    x: t,
    y: i,
    width: s,
    height: r,
    top: i,
    right: t + s,
    bottom: r + i,
    left: t
  }), n;
}
function B(e, t, i, s) {
  return { x: e, y: t, width: i, height: s };
}
var pt = function() {
  function e(t) {
    this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = B(0, 0, 0, 0), this.target = t;
  }
  return e.prototype.isActive = function() {
    var t = ct(this.target);
    return this.contentRect_ = t, t.width !== this.broadcastWidth || t.height !== this.broadcastHeight;
  }, e.prototype.broadcastRect = function() {
    var t = this.contentRect_;
    return this.broadcastWidth = t.width, this.broadcastHeight = t.height, t;
  }, e;
}(), vt = function() {
  function e(t, i) {
    var s = ft(i);
    be(this, { target: t, contentRect: s });
  }
  return e;
}(), gt = function() {
  function e(t, i, s) {
    if (this.activeObservations_ = [], this.observations_ = new we(), typeof t != "function")
      throw new TypeError("The callback provided as parameter 1 is not a function.");
    this.callback_ = t, this.controller_ = i, this.callbackCtx_ = s;
  }
  return e.prototype.observe = function(t) {
    if (!arguments.length)
      throw new TypeError("1 argument required, but only 0 present.");
    if (!(typeof Element > "u" || !(Element instanceof Object))) {
      if (!(t instanceof L(t).Element))
        throw new TypeError('parameter 1 is not of type "Element".');
      var i = this.observations_;
      i.has(t) || (i.set(t, new pt(t)), this.controller_.addObserver(this), this.controller_.refresh());
    }
  }, e.prototype.unobserve = function(t) {
    if (!arguments.length)
      throw new TypeError("1 argument required, but only 0 present.");
    if (!(typeof Element > "u" || !(Element instanceof Object))) {
      if (!(t instanceof L(t).Element))
        throw new TypeError('parameter 1 is not of type "Element".');
      var i = this.observations_;
      !i.has(t) || (i.delete(t), i.size || this.controller_.removeObserver(this));
    }
  }, e.prototype.disconnect = function() {
    this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this);
  }, e.prototype.gatherActive = function() {
    var t = this;
    this.clearActive(), this.observations_.forEach(function(i) {
      i.isActive() && t.activeObservations_.push(i);
    });
  }, e.prototype.broadcastActive = function() {
    if (!!this.hasActive()) {
      var t = this.callbackCtx_, i = this.activeObservations_.map(function(s) {
        return new vt(s.target, s.broadcastRect());
      });
      this.callback_.call(t, i, t), this.clearActive();
    }
  }, e.prototype.clearActive = function() {
    this.activeObservations_.splice(0);
  }, e.prototype.hasActive = function() {
    return this.activeObservations_.length > 0;
  }, e;
}(), Te = typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : new we(), _e = function() {
  function e(t) {
    if (!(this instanceof e))
      throw new TypeError("Cannot call a class as a function.");
    if (!arguments.length)
      throw new TypeError("1 argument required, but only 0 present.");
    var i = lt.getInstance(), s = new gt(t, i, this);
    Te.set(this, s);
  }
  return e;
}();
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(e) {
  _e.prototype[e] = function() {
    var t;
    return (t = Te.get(this))[e].apply(t, arguments);
  };
});
var yt = function() {
  return typeof H.ResizeObserver < "u" ? H.ResizeObserver : _e;
}();
const Y = (e) => {
  let t, i, s, r, l;
  e.rtl ? l = e.slideCount - 1 - e.index : l = e.index, s = l < 0 || l >= e.slideCount, e.centerMode ? (r = Math.floor(e.slidesToShow / 2), i = (l - e.currentSlide) % e.slideCount === 0, l > e.currentSlide - r - 1 && l <= e.currentSlide + r && (t = !0)) : t = e.currentSlide <= l && l < e.currentSlide + e.slidesToShow;
  let n = l === e.currentSlide;
  return {
    "slick-slide": !0,
    "slick-active": t,
    "slick-center": i,
    "slick-cloned": s,
    "slick-current": n
  };
}, St = (e) => {
  let t = {};
  return (e.variableWidth === void 0 || e.variableWidth === !1) && (t.width = typeof e.slideWidth == "number" ? `${e.slideWidth}px` : e.slideWidth), e.fade && (t.position = "relative", e.vertical ? t.top = `${-e.index * parseInt(e.slideHeight)}px` : t.left = `${-e.index * parseInt(e.slideWidth)}px`, t.opacity = e.currentSlide === e.index ? 1 : 0, t.transition = "opacity " + e.speed + "ms " + e.cssEase + ", visibility " + e.speed + "ms " + e.cssEase), t;
}, F = (e, t) => e.key != null && String(e.key) || t, mt = {
  name: "SliderTrack",
  props: $.TRACK,
  methods: {
    cloneSlide(e, t) {
      let i = Q(e);
      return i.key = t.key, T(i, "class", t.class), T(i, "attrs", t.attrs), T(i, "style", t.style), T(i, "on", {
        click: (s) => {
          q(e, "on.click", () => {
          })(s), this.$emit("childClicked", t.childOnClickOptions);
        }
      }), i;
    },
    renderSlides(e, t) {
      let i, s = [], r = [], l = [], n = t.length, o = ge(e), a = ye(e);
      return t.forEach((d, f) => {
        let p, y = {
          message: "children",
          index: f,
          slidesToScroll: e.slidesToScroll,
          currentSlide: e.currentSlide
        };
        !e.lazyLoad || e.lazyLoad && e.lazyLoadedList.indexOf(f) >= 0 ? p = d : p = S("div", null, null);
        let g = St({
          ...e,
          index: f
        }), c = Y({
          ...e,
          index: f
        });
        if (s.push(this.cloneSlide(p, {
          key: "original" + F(p, f),
          class: c,
          style: {
            outline: "none",
            ...g
          },
          attrs: {
            tabIndex: "-1",
            "data-index": f,
            "aria-hidden": `${!c["slick-active"]}`
          },
          childOnClickOptions: y
        })), e.infinite && e.fade === !1 && n > e.slidesToShow) {
          let u = n - f;
          u <= O(e) && n !== e.slidesToShow && (i = -u, i >= o && (p = d), c = Y({
            ...e,
            index: i
          }), r.push(this.cloneSlide(p, {
            key: "precloned" + F(p, i),
            class: c,
            style: g,
            attrs: {
              tabIndex: "-1",
              "data-index": i,
              "aria-hidden": `${!c["slick-active"]}`
            },
            childOnClickOptions: y
          }))), n !== e.slidesToShow && (i = n + f, i < a && (p = d), c = Y({
            ...e,
            index: i
          }), l.push(this.cloneSlide(p, {
            key: "postcloned" + F(p, i),
            class: c,
            style: g,
            attrs: {
              tabIndex: "-1",
              "data-index": i,
              "aria-hidden": `${!c["slick-active"]}`
            },
            childOnClickOptions: y
          })));
        }
      }, this), e.rtl ? r.concat(s, l).reverse() : r.concat(s, l);
    }
  },
  render() {
    const e = this.renderSlides(this.$props, this.$slots.default);
    return S("div", {
      class: {
        "slick-track": !0,
        "slick-center": this.$props.centerMode
      },
      style: this.trackStyle
    }, [e]);
  }
};
const ee = (e, t) => {
  const i = e.__vccOpts || e;
  for (const [s, r] of t)
    i[s] = r;
  return i;
}, de = /* @__PURE__ */ ee(mt, [["__scopeId", "data-v-7fe52038"]]), wt = {
  name: "SliderArrow",
  props: [...$.ARROW, "type"],
  render() {
    let e = {
      "slick-arrow": !0
    }, t = !0, i, s = {
      currentSlide: this.currentSlide,
      slideCount: this.slideCount
    };
    return this.type === "previous" ? (e["slick-prev"] = !0, !this.infinite && (this.currentSlide === 0 || this.slideCount <= this.slidesToShow) && (e["slick-disabled"] = !0, t = !1), s.key = "0", i = this.prevArrow ? this.prevArrow(s)[0] : S("button", {
      type: "button",
      "data-role": "none",
      style: "display: block;"
    }, [ie("Previous")])) : (e["slick-next"] = !0, N(this.$props) || (e["slick-disabled"] = !0, t = !1), s.key = "1", i = this.nextArrow ? this.nextArrow(s)[0] : S("button", {
      type: "button",
      "data-role": "none",
      style: "display: block;"
    }, [ie("Next")])), pe(i, "key", s.key), T(i, "class", e), T(i, "on", {
      click: () => {
        t && this.$emit("arrowClicked", {
          message: this.type
        });
      }
    }), i;
  }
};
const X = /* @__PURE__ */ ee(wt, [["__scopeId", "data-v-38f6ef85"]]), bt = (e) => {
  let t;
  return e.infinite ? t = Math.ceil(e.slideCount / e.slidesToScroll) : t = Math.ceil((e.slideCount - e.slidesToShow) / e.slidesToScroll) + 1, t;
}, ue = {
  name: "SliderDots",
  props: $.DOT,
  render() {
    let e = bt({
      slideCount: this.slideCount,
      slidesToScroll: this.slidesToScroll,
      slidesToShow: this.slidesToShow,
      infinite: this.infinite
    }), t = Array.apply(null, Array(e + 1).join("0").split("")).map((r, l) => {
      let n = l * this.slidesToScroll, o = l * this.slidesToScroll + (this.slidesToScroll - 1), a = {
        "slick-active": this.currentSlide >= n && this.currentSlide <= o
      }, d = {
        message: "dots",
        index: l,
        slidesToScroll: this.slidesToScroll,
        currentSlide: this.currentSlide
      };
      const f = this.customPaging ? this.customPaging(l)[0] : S("button", null, [l + 1]);
      return S("li", {
        key: l,
        class: a,
        onClick: () => this.$emit("dotClicked", d)
      }, [f]);
    });
    const i = {
      display: "block"
    }, s = {
      [this.dotsClass]: !0
    };
    return S("ul", {
      style: i,
      class: s
    }, [t]);
  }
}, kt = {
  animating: !1,
  autoplaying: null,
  currentDirection: 0,
  currentLeft: null,
  currentSlide: 0,
  direction: 1,
  dragging: !1,
  edgeDragged: !1,
  initialized: !1,
  lazyLoadedList: [],
  listHeight: null,
  listWidth: null,
  scrolling: !1,
  slideHeight: null,
  slideWidth: null,
  swipeLeft: null,
  swiped: !1,
  swiping: !1,
  touchObject: { startX: 0, startY: 0, curX: 0, curY: 0 },
  trackStyle: {},
  trackWidth: 0
}, Tt = {
  name: "InnerSlider",
  components: {
    SliderTrack: de,
    SliderArrow: X,
    SliderDots: ue
  },
  mixins: [fe],
  inheritAttrs: !1,
  props: {
    ...C,
    unslick: {
      type: Boolean,
      default: !1
    },
    prevArrow: Function,
    nextArrow: Function,
    customPaging: Function
  },
  data() {
    return {
      ...kt,
      currentSlide: this.initialSlide
    };
  },
  computed: {
    slideCount() {
      return this.$slots.default.length;
    },
    spec() {
      return {
        ...this.$props,
        ...this.$data,
        slideCount: this.slideCount
      };
    }
  },
  created() {
    if (this.callbackTimers = [], this.clickable = !0, this.debouncedResize = null, this.ssrInit(), this.$parent.$emit("init"), this.lazyLoad) {
      let e = D(this.spec);
      e.length > 0 && (this.lazyLoadedList = this.lazyLoadedList.concat(e), this.$parent.$emit("lazyLoad", e));
    }
  },
  mounted() {
    let e = {
      listRef: this.$refs.list,
      trackRef: this.$refs.track,
      children: this.$slots.default,
      ...this.$props
    };
    this.updateState(e, !0), this.adaptHeight(), this.autoPlay && this.autoPlay("update"), this.lazyLoad === "progressive" && (this.lazyLoadTimer = setInterval(this.progressiveLazyLoad, 1e3)), this.ro = new yt(() => {
      this.animating ? (this.onWindowResized(!1), this.callbackTimers.push(setTimeout(() => this.onWindowResized(), this.speed))) : this.onWindowResized();
    }), this.ro.observe(this.$refs.list), Array.prototype.forEach.call(this.$refs.list.querySelectorAll(".slick-slide"), (t) => {
      t.onfocus = this.pauseOnFocus ? this.onSlideFocus : null, t.onblur = this.pauseOnFocus ? this.onSlideBlur : null;
    }), window.addEventListener ? window.addEventListener("resize", this.onWindowResized) : window.attachEvent("onresize", this.onWindowResized);
  },
  updated() {
    if (this.checkImagesLoad(), this.$parent.$emit("reInit"), this.lazyLoad) {
      let e = D({
        ...this.$props,
        ...this.$data
      });
      e.length > 0 && (this.lazyLoadedList = this.lazyLoadedList.concat(e), this.$parent.$emit("lazyLoad", e));
    }
    this.adaptHeight();
  },
  beforeDestroy() {
    this.ro.unobserve(this.$refs.list), this.animationEndCallback && clearTimeout(this.animationEndCallback), this.lazyLoadTimer && clearInterval(this.lazyLoadTimer), this.callbackTimers.length && (this.callbackTimers.forEach((e) => clearTimeout(e)), this.callbackTimers = []), window.addEventListener ? window.removeEventListener("resize", this.onWindowResized) : window.detachEvent("onresize", this.onWindowResized), this.autoplayTimer && clearInterval(this.autoplayTimer);
  },
  methods: {
    onPropsUpdated() {
      const e = this.$props;
      let t = {
        listRef: this.$refs.list,
        trackRef: this.$refs.track,
        children: this.$slots.default,
        ...e,
        ...this.$data
      }, i = !1;
      for (let s of Object.keys(this.$props)) {
        if (!e.hasOwnProperty(s)) {
          i = !0;
          break;
        }
        if (!(typeof e[s] == "object" || typeof e[s] == "function") && e[s] !== this.$props[s]) {
          i = !0;
          break;
        }
      }
      this.updateState(t, i), this.currentSlide >= this.slideCount && this.changeSlide({
        message: "index",
        index: this.slideCount - e.slidesToShow,
        currentSlide: this.currentSlide
      }), e.autoplay ? this.autoPlay("update") : this.pause("paused");
    },
    updateState(e, t) {
      let i = Ze(e);
      e = {
        ...e,
        ...i,
        slideIndex: i.currentSlide
      };
      let s = W(e);
      e = {
        ...e,
        left: s
      };
      let r = P(e);
      (t || this.slideCount !== e.children.length) && (i.trackStyle = r), Object.assign(this.$data, i);
    },
    adaptHeight() {
      if (this.adaptiveHeight && this.$refs.list) {
        const e = this.$refs.list.querySelector(`[data-index="${this.currentSlide}"]`);
        this.$refs.list.style.height = Z(e) + "px";
      }
    },
    ssrInit() {
      const e = O(this.spec), t = G(this.spec);
      if (this.variableWidth) {
        let i = [], s = [], r = [];
        this.$slots.default.forEach((n) => {
          const {
            width: o
          } = V(n);
          r.push(o), i.push(o);
        });
        for (let n = 0; n < e; n++)
          s.push(r[r.length - 1 - n]), i.push(r[r.length - 1 - n]);
        for (let n = 0; n < t; n++)
          i.push(r[n]);
        for (let n = 0; n < this.currentSlide; n++)
          s.push(r[n]);
        i = i.filter((n) => n), s = s.filter((n) => n);
        let l = {
          width: `calc(${i.join(" + ")})`,
          left: `calc(${s.map((n) => `-${n}`).join(" + ")})`
        };
        if (this.centerMode) {
          let n = r[this.currentSlide];
          l.left = `calc(${s.map((o) => `-${o}`).join(" + ")} + (100% - ${n}) / 2 )`;
        }
        this.trackStyle = l;
      } else {
        let i = e + t + this.slideCount, s = 100 / this.slidesToShow * i, r = 100 / i, l = -r * (e + this.currentSlide) * s / 100;
        this.centerMode && (l += (100 - r * s / 100) / 2), this.slideWidth = r + "%", this.trackStyle = {
          width: s + "%",
          left: l + "%"
        };
      }
    },
    slideHandler(e, t = !1) {
      const {
        asNavFor: i,
        speed: s
      } = this, r = this.currentSlide;
      let {
        state: l,
        nextState: n
      } = Qe({
        index: e,
        ...this.$props,
        ...this.$data,
        trackRef: this.$refs.track,
        useCSS: this.useCSS && !t
      });
      if (!l)
        return;
      this.$parent.$emit("beforeChange", r, l.currentSlide);
      let o = l.lazyLoadedList.filter((a) => this.lazyLoadedList.indexOf(a) < 0);
      o.length && this.$parent.$emit("lazyLoad", o), Object.assign(this.$data, l), i && i.goTo(e), n && (this.animationEndCallback = setTimeout(() => {
        const {
          animating: a,
          ...d
        } = n;
        Object.assign(this.$data, d), this.callbackTimers.push(setTimeout(() => {
          this.animating = a;
        }, 10)), this.$parent.$emit("afterChange", l.currentSlide), this.animationEndCallback = void 0;
      }, s));
    },
    onWindowResized(e) {
      this.debouncedResize && this.debouncedResize.cancel(), this.debouncedResize = Ee(() => this.resizeWindow(e), 50), this.debouncedResize();
    },
    resizeWindow(e = !0) {
      if (!(this.$refs.track && this.$refs.track.$el))
        return;
      let t = {
        listRef: this.$refs.list,
        trackRef: this.$refs.track,
        children: this.$slots.default,
        ...this.$props,
        ...this.$data
      };
      this.updateState(t, e), this.autoplay ? this.autoPlay("update") : this.pause("paused"), this.animating = !1, clearTimeout(this.animationEndCallback), this.animationEndCallback = void 0;
    },
    checkImagesLoad() {
      let e = this.$refs.list.querySelectorAll(".slick-slide img"), t = e.length, i = 0;
      Array.prototype.forEach.call(e, (s) => {
        const r = () => ++i && i >= t && this.onWindowResized();
        if (!s.onclick)
          s.onclick = () => s.parentNode.focus();
        else {
          const l = s.onclick;
          s.onclick = () => {
            l(), s.parentNode.focus();
          };
        }
        s.onload || (this.lazyLoad ? s.onload = () => {
          this.adaptHeight(), this.callbackTimers.push(setTimeout(this.onWindowResized, this.speed));
        } : (s.onload = r, s.onerror = () => {
          r(), this.$parent.$emit("lazyLoadError");
        }));
      });
    },
    progressiveLazyLoad() {
      let e = [];
      const t = {
        ...this.$props,
        ...this.$data
      };
      for (let i = this.currentSlide; i < this.slideCount + G(t); i++)
        if (this.lazyLoadedList.indexOf(i) < 0) {
          e.push(i);
          break;
        }
      for (let i = this.currentSlide - 1; i >= -O(t); i--)
        if (this.lazyLoadedList.indexOf(i) < 0) {
          e.push(i);
          break;
        }
      e.length > 0 ? (this.lazyLoadedList = this.lazyLoadedList.concat(e), this.$parent.$emit("lazyLoad", e)) : this.lazyLoadTimer && (clearInterval(this.lazyLoadTimer), this.lazyLoadTimer = void 0);
    },
    clickHandler(e) {
      this.clickable === !1 && (e.stopPropagation(), e.preventDefault()), this.clickable = !0;
    },
    keyHandler(e) {
      let t = Ie(e, this.accessibility, this.rtl);
      t !== "" && this.changeSlide({
        message: t
      });
    },
    changeSlide(e, t = !1) {
      const i = {
        ...this.$props,
        ...this.$data
      };
      let s = Xe(i, e);
      s !== 0 && !s || (t === !0 ? this.slideHandler(s, t) : this.slideHandler(s));
    },
    swipeStart(e) {
      this.verticalSwiping && this.disableBodyScroll();
      let t = Ve(e, this.swipe, this.draggable);
      t !== "" && Object.assign(this.$data, t);
    },
    swipeMove(e) {
      let t = Ge(e, {
        ...this.$props,
        ...this.$data,
        trackRef: this.$refs.track,
        listRef: this.$refs.list,
        slideIndex: this.currentSlide,
        onEdge: (i) => this.$parent.$emit("edge", i),
        swipeEvent: (i) => this.$parent.$emit("swipe", i)
      });
      !t || (t.swiping && (this.clickable = !1), Object.assign(this.$data, t));
    },
    swipeEnd(e) {
      let t = Ke(e, {
        ...this.$props,
        ...this.$data,
        trackRef: this.$refs.track,
        listRef: this.$refs.list,
        slideIndex: this.currentSlide
      });
      if (!t)
        return;
      let i = t.triggerSlideHandler;
      this.triggerSlideHandler = void 0, Object.assign(this.$data, t), i !== void 0 && (this.slideHandler(i), this.verticalSwiping && this.enableBodyScroll());
    },
    prev() {
      this.callbackTimers.push(setTimeout(() => this.changeSlide({
        message: "previous"
      }), 0));
    },
    next() {
      this.callbackTimers.push(setTimeout(() => this.changeSlide({
        message: "next"
      }), 0));
    },
    goTo(e, t = !1) {
      if (e = Number(e), isNaN(e))
        return "";
      this.callbackTimers.push(setTimeout(() => this.changeSlide({
        message: "index",
        index: e,
        currentSlide: this.currentSlide
      }, t), 0));
    },
    play() {
      var e;
      if (this.rtl)
        e = this.currentSlide - this.slidesToScroll;
      else if (N({
        ...this.$props,
        ...this.$data
      }))
        e = this.currentSlide + this.slidesToScroll;
      else
        return !1;
      this.slideHandler(e);
    },
    autoPlay(e) {
      this.autoplayTimer && clearInterval(this.autoplayTimer);
      const t = this.autoplaying;
      if (e === "update") {
        if (t === "hovered" || t === "focused" || t === "paused")
          return;
      } else if (e === "leave") {
        if (t === "paused" || t === "focused")
          return;
      } else if (e === "blur" && (t === "paused" || t === "hovered"))
        return;
      this.autoplayTimer = setInterval(this.play, this.autoplaySpeed + 50), this.autoplaying = "playing";
    },
    pause(e) {
      this.autoplayTimer && (clearInterval(this.autoplayTimer), this.autoplayTimer = null);
      const t = this.autoplaying;
      e === "paused" ? this.autoplaying = "paused" : e === "focused" ? (t === "hovered" || t === "playing") && (this.autoplaying = "focused") : t === "playing" && (this.autoplaying = "hovered");
    },
    onDotsOver() {
      this.autoplay && this.pause("hovered");
    },
    onDotsLeave() {
      this.autoplay && this.autoplaying === "hovered" && this.autoPlay("leave");
    },
    onTrackOver() {
      this.autoplay && this.pause("hovered");
    },
    onTrackLeave() {
      this.autoplay && this.autoplaying === "hovered" && this.autoPlay("leave");
    },
    onSlideFocus() {
      this.autoplay && this.pause("focused");
    },
    onSlideBlur() {
      this.autoplay && this.autoplaying === "focused" && this.autoPlay("blur");
    },
    selectHandler(e) {
      this.focusOnSelect && this.changeSlide(e);
    }
  },
  render() {
    const e = {
      "slick-slider": !0,
      "slick-initialized": !0,
      "slick-vertical": this.vertical
    };
    let t = j(this.spec, $.TRACK);
    t = M({
      ...t
    });
    const {
      pauseOnHover: i
    } = this, s = M({
      mouseenter: i ? this.onTrackOver : void 0,
      mouseover: i ? this.onTrackOver : void 0,
      mouseleave: i ? this.onTrackLeave : void 0
    });
    let r;
    if (this.dots === !0 && this.slideCount >= this.slidesToShow) {
      let u = j(this.spec, $.DOT);
      const {
        pauseOnDotsHover: v
      } = this, h = M({
        mouseenter: v ? this.onDotsLeave : void 0,
        mouseover: v ? this.onDotsOver : void 0,
        mouseleave: v ? this.onDotsLeave : void 0
      });
      r = S(ue, x({
        props: u
      }, {
        nativeOn: h
      }, {
        onDotClicked: this.changeSlide
      }), null);
    }
    let l, n, o = j(this.spec, $.ARROW);
    this.arrows && (l = S(X, x({
      props: {
        ...o,
        type: "previous"
      }
    }, {
      onArrowClicked: this.changeSlide
    }), null), n = S(X, x({
      props: {
        ...o,
        type: "next"
      }
    }, {
      onArrowClicked: this.changeSlide
    }), null));
    var a = {};
    this.vertical && (a = {
      height: `${this.listHeight}px`
    });
    var d = {};
    this.vertical === !1 ? this.centerMode === !0 && (d = {
      padding: "0px " + this.centerPadding
    }) : this.centerMode === !0 && (d = {
      padding: this.centerPadding + " 0px"
    });
    let f = {
      ...this.$parent.$vnode.data.style
    };
    this.unslick || (f = {
      ...f,
      ...qe(a),
      ...d
    });
    const {
      accessibility: p,
      dragging: y,
      touchMove: g
    } = this, c = M({
      click: this.clickHandler,
      mousedown: g ? this.swipeStart : void 0,
      mousemove: y && g ? this.swipeMove : void 0,
      mouseup: g ? this.swipeEnd : void 0,
      mouseleave: y && g ? this.swipeEnd : void 0,
      touchstart: g ? this.swipeStart : void 0,
      touchmove: y && g ? this.swipeMove : void 0,
      touchend: g ? this.swipeEnd : void 0,
      touchcancel: y && g ? this.swipeEnd : void 0,
      keydown: p ? this.keyHandler : void 0
    });
    return S("div", {
      class: e,
      dir: this.unslick ? !1 : "ltr"
    }, [this.unslick ? "" : l, S("div", x({
      ref: "list",
      class: "slick-list"
    }, {
      on: c
    }, {
      style: f
    }), [S(de, x({
      ref: "track"
    }, {
      props: t
    }, {
      nativeOn: s
    }, {
      onChildClicked: this.selectHandler
    }), {
      default: () => [this.$slots.default]
    })]), this.unslick ? "" : n, this.unslick ? "" : r]);
  }
};
const he = /* @__PURE__ */ ee(Tt, [["__scopeId", "data-v-b80cd38e"]]);
function _t(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !xe(e);
}
const ce = ve() && require("enquire.js"), $t = {
  name: "VueSlickCarousel",
  components: {
    InnerSlider: he
  },
  mixins: [fe],
  inheritAttrs: !1,
  props: C,
  data() {
    return {
      breakpoint: null
    };
  },
  computed: {
    settings() {
      const e = M(this.$props);
      let t, i;
      return this.breakpoint ? (i = this.responsive.filter((s) => s.breakpoint === this.breakpoint), t = i[0].settings === "unslick" ? "unslick" : {
        ...oe,
        ...e,
        ...i[0].settings
      }) : t = {
        ...oe,
        ...e
      }, t.centerMode && (t.slidesToScroll > 1 && process.env.NODE_ENV !== "production" && console.warn(`slidesToScroll should be equal to 1 in centerMode, you are using ${t.slidesToScroll}`), t.slidesToScroll = 1), t.fade && (t.slidesToShow > 1 && process.env.NODE_ENV !== "production" && console.warn(`slidesToShow should be equal to 1 when fade is true, you're using ${t.slidesToShow}`), t.slidesToScroll > 1 && process.env.NODE_ENV !== "production" && console.warn(`slidesToScroll should be equal to 1 when fade is true, you're using ${t.slidesToScroll}`), t.slidesToShow = 1, t.slidesToScroll = 1), t.variableWidth && (t.rows > 1 || t.slidesPerRow > 1) && (console.warn("variableWidth is not supported in case of rows > 1 or slidesPerRow > 1"), t.variableWidth = !1), t;
    }
  },
  created() {
    this.makeBreakpoints();
  },
  beforeDestroy() {
    this.clearBreakpoints();
  },
  methods: {
    prev() {
      this.$refs.innerSlider.prev();
    },
    next() {
      this.$refs.innerSlider.next();
    },
    goTo(e, t = !1) {
      this.$refs.innerSlider.goTo(e, t);
    },
    pause() {
      this.$refs.innerSlider.pause("paused");
    },
    play() {
      this.$refs.innerSlider.autoPlay("play");
    },
    onPropsUpdated() {
      this.clearBreakpoints(), this.makeBreakpoints();
    },
    clearBreakpoints() {
      this.responsiveMediaHandlers.forEach((e) => ce.unregister(e.query, e.handler)), this.responsiveMediaHandlers = [];
    },
    media(e, t) {
      !ve() || (ce.register(e, t), this.responsiveMediaHandlers.push({
        query: e,
        handler: t
      }));
    },
    makeBreakpoints() {
      if (this.breakpoint = null, this.responsiveMediaHandlers = [], this.responsive) {
        let e = this.responsive.map((i) => i.breakpoint);
        e.sort((i, s) => i - s), e.forEach((i, s) => {
          const r = re({
            minWidth: s === 0 ? 0 : e[s - 1] + 1,
            maxWidth: i
          });
          this.media(r, () => {
            this.breakpoint = i;
          });
        });
        const t = re({
          minWidth: e.slice(-1)[0]
        });
        this.media(t, () => {
          this.breakpoint = null;
        });
      }
    }
  },
  render() {
    const {
      settings: e
    } = this;
    let t = this.$slots.default || [];
    if (e === "unslick")
      return S("div", {
        class: "regular slider"
      }, [t]);
    e.prevArrow = this.$scopedSlots.prevArrow, e.nextArrow = this.$scopedSlots.nextArrow, e.customPaging = this.$scopedSlots.customPaging, t = t.filter((r) => !!r.tag);
    let i = [], s = null;
    for (let r = 0; r < t.length; r += e.rows * e.slidesPerRow) {
      let l = [];
      for (let n = r; n < r + e.rows * e.slidesPerRow; n += e.slidesPerRow) {
        let o = [];
        for (let a = n; a < n + e.slidesPerRow && (e.variableWidth && V(t[a]) && (s = V(t[a]).width), !(a >= t.length)); a += 1) {
          let d = Q(t[a]);
          pe(d, "key", 100 * r + 10 * n + a), T(d, "attrs", {
            tabIndex: -1
          }), T(d, "style", {
            width: `${100 / e.slidesPerRow}%`,
            display: "inline-block"
          }), o.push(d);
        }
        l.push(S("div", {
          key: 10 * r + n
        }, [o]));
      }
      e.variableWidth ? i.push(S("div", {
        key: r,
        style: {
          width: s
        }
      }, [l])) : i.push(S("div", {
        key: r
      }, [l]));
    }
    return i.length <= e.slidesToShow && (e.unslick = !0), S(he, x({
      ref: "innerSlider"
    }, {
      props: e
    }, {
      key: Object.values(e).join("")
    }), _t(i) ? i : {
      default: () => [i]
    });
  }
}, Ct = {
  install(e) {
    for (const t in components)
      if (components.hasOwnProperty(t)) {
        const i = components[t];
        e.component(i.name, i);
      }
  }
};
export {
  $t as Carousel,
  Ct as plugin
};
